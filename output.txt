--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\auth.py ---
import json
import hashlib
import os
from utils import log_event, create_directory_if_not_exists, COLOR_RED, COLOR_GREEN

USERS_FILE = 'users.json'
class User:
    def __init__(self, username, password_hash):
        self.username = username
        self.password_hash = password_hash

    def to_dict(self):
        return {"username": self.username, "password_hash": self.password_hash}

    @staticmethod
    def from_dict(data):
        return User(data["username"], data["password_hash"])

class AuthService:
    def __init__(self):
        self.users = self._load_users()
        log_event(f"AuthService zainicjalizowany, załadowano {len(self.users)} użytkowników.", level="DEBUG")

    def _hash_password(self, password):
        return hashlib.sha256(password.encode()).hexdigest()

    def _load_users(self):
        if not os.path.exists(USERS_FILE):
            log_event(f"Plik użytkowników {USERS_FILE} nie istnieje. Zwracam pusty słownik.", level="INFO")
            return {}
        try:
            with open(USERS_FILE, 'r') as f:
                users_data = json.load(f)
                log_event(f"Załadowano dane użytkowników z {USERS_FILE}.", level="DEBUG")
                return users_data
        except (json.JSONDecodeError, FileNotFoundError) as e:
            log_event(f"Błąd podczas ładowania pliku użytkowników {USERS_FILE}: {e}", level="ERROR", color=COLOR_RED)
            return {}

    def _save_users(self):
        try:
            with open(USERS_FILE, 'w') as f:
                json.dump(self.users, f, indent=4)
            log_event(f"Zapisano dane użytkowników do {USERS_FILE}.", level="DEBUG")
        except IOError as e:
            log_event(f"Błąd podczas zapisywania danych użytkowników do {USERS_FILE}: {e}", level="ERROR", color=COLOR_RED)


    def register(self, username, password):
        if not username or not password:
            log_event(f"Próba rejestracji z pustą nazwą użytkownika lub hasłem.", level="WARNING")
            return False, "Nazwa użytkownika i hasło nie mogą być puste."
        if username in self.users:
            log_event(f"Nieudana próba rejestracji: użytkownik '{username}' już istnieje.", level="INFO")
            return False, "Użytkownik o tej nazwie już istnieje."
        
        hashed_password = self._hash_password(password)
        self.users[username] = hashed_password
        self._save_users()
        log_event(f"Użytkownik '{username}' zarejestrowany pomyślnie.", level="INFO", color=COLOR_GREEN)
        return True, "Rejestracja zakończona sukcesem."

    def login(self, username, password):
        if not username or not password:
            log_event(f"Próba logowania z pustą nazwą użytkownika lub hasłem.", level="WARNING")
            return False, "Nazwa użytkownika i hasło nie mogą być puste."
        
        stored_password_hash = self.users.get(username)
        if not stored_password_hash:
            log_event(f"Nieudana próba logowania: użytkownik '{username}' nie znaleziony.", level="INFO")
            return False, "Nieprawidłowa nazwa użytkownika lub hasło."
        
        hashed_password = self._hash_password(password)
        if hashed_password == stored_password_hash:
            log_event(f"Użytkownik '{username}' zalogowany pomyślnie.", level="INFO", color=COLOR_GREEN)
            return True, "Logowanie zakończone sukcesem."
        else:
            log_event(f"Nieudana próba logowania dla użytkownika '{username}': nieprawidłowe hasło.", level="INFO", color=COLOR_RED)
            return False, "Nieprawidłowa nazwa użytkownika lub hasło."
--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\auth.py ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\characters.py ---

import random
from items import Item, Weapon, Armor, Potion, ALL_DEFAULT_ITEMS
from utils import (
    log_event, roll_dice_expression, clamp, calculate_level_xp_threshold, 
    COLOR_RED, COLOR_GREEN, COLOR_YELLOW, safe_nested_get, generate_random_syllabic_name
)

class Character:
    def __init__(self, name, hp, attack, defense):
        self.name = name if name else generate_random_syllabic_name(min_syl=2, max_syl=3)
        self.max_hp = hp
        self.hp = hp
        self.attack_power = attack 
        self.defense_power = defense
        self.is_blocking = False

    def take_damage(self, damage):
        actual_damage_taken = 0
        log_message_parts = []

        if self.is_blocking:
            effective_defense = self.get_total_defense() * 2 
            reduced_damage = clamp(damage - effective_defense, 0, damage)
            actual_damage_taken = reduced_damage
            msg = f"{self.name} blokuje atak! Obrona: {effective_defense}. Otrzymuje {actual_damage_taken} obrażeń (z {damage})."
            log_event(msg, level="DEBUG", color=COLOR_YELLOW)
            log_message_parts.append(f"{self.name} blokuje i otrzymuje {actual_damage_taken} obrażeń!")
            self.is_blocking = False
        else:
            effective_defense = self.get_total_defense()
            reduced_damage = clamp(damage - effective_defense, 0, damage)
            actual_damage_taken = reduced_damage
            msg = f"{self.name} otrzymuje {actual_damage_taken} obrażeń (z {damage}, obrona: {effective_defense})."
            log_event(msg, level="DEBUG", color=COLOR_RED)
            log_message_parts.append(f"{self.name} otrzymuje {actual_damage_taken} obrażeń.")
        
        self.hp = clamp(self.hp - actual_damage_taken, 0, self.max_hp)
        
        if self.hp == 0:
            log_event(f"{self.name} został pokonany!", level="INFO", color=COLOR_RED)
            log_message_parts.append(f"{self.name} pada nieprzytomny!")
            
        return actual_damage_taken, " ".join(log_message_parts)


    def is_alive(self):
        return self.hp > 0

    def get_total_attack(self):
        return self.attack_power

    def get_total_defense(self):
        return self.defense_power

    def attack_target(self, target):
        if not self.is_alive():
            return None, f"{self.name} nie może atakować, jest nieprzytomny."

        base_damage = self.get_total_attack()
        weapon_damage_roll = 0
        
        if hasattr(self, 'equipped_weapon') and self.equipped_weapon and self.equipped_weapon.damage_dice:
            try:
                weapon_damage_roll = roll_dice_expression(self.equipped_weapon.damage_dice)
                log_event(f"{self.name} rzuca {self.equipped_weapon.damage_dice} dla broni: {weapon_damage_roll}", level="DEBUG")
            except ValueError as e:
                log_event(f"Błąd w notacji kości dla broni {self.equipped_weapon.name}: {e}", level="ERROR", color=COLOR_RED)
                weapon_damage_roll = self.equipped_weapon.damage
        elif hasattr(self, 'equipped_weapon') and self.equipped_weapon:
             weapon_damage_roll = self.equipped_weapon.damage
        else:
            weapon_damage_roll = roll_dice_expression("1d3")

        potential_damage = base_damage + weapon_damage_roll + random.randint(-1,1)
        potential_damage = max(1, potential_damage)

        log_event(f"{self.name} (Atk:{base_damage}) atakuje {target.name} z potencjalnymi obrażeniami: {potential_damage} (broń: {weapon_damage_roll}).", level="INFO")
        
        actual_damage_inflicted, damage_message = target.take_damage(potential_damage)
        
        attack_log_message = f"{self.name} atakuje {target.name}. {damage_message}"
        return actual_damage_inflicted, attack_log_message

    def block(self):
        log_event(f"{self.name} przygotowuje się do bloku!", level="INFO", color=COLOR_YELLOW)
        self.is_blocking = True
        return f"{self.name} przygotowuje się do bloku!"

    def heal(self, amount):
        hp_before = self.hp
        self.hp = clamp(self.hp + amount, 0, self.max_hp)
        healed_amount = self.hp - hp_before
        msg = f"{self.name} leczy się o {healed_amount} HP (do {self.hp}/{self.max_hp})."
        log_event(msg, level="INFO", color=COLOR_GREEN)
        return healed_amount, msg


    def __str__(self):
        return f"{self.name} (HP: {self.hp}/{self.max_hp}, Baz.Atk: {self.attack_power}, Baz.Def: {self.defense_power})"

class Player(Character):
    def __init__(self, name, chosen_class="Wojownik"):
        if chosen_class == "Wojownik":
            super().__init__(name, hp=100, attack=10, defense=5)
            self.equipped_weapon = ALL_DEFAULT_ITEMS["old_sword"]
            self.equipped_armor = ALL_DEFAULT_ITEMS["leather_vest_worn"]
        elif chosen_class == "Mag":
            super().__init__(name, hp=70, attack=8, defense=3) 
            self.equipped_weapon = ALL_DEFAULT_ITEMS["apprentice_staff_branch"]
            self.equipped_armor = ALL_DEFAULT_ITEMS["cloth_robe_simple"]
        else: 
            super().__init__(name, hp=100, attack=10, defense=5)
            self.equipped_weapon = ALL_DEFAULT_ITEMS["old_sword"]
            self.equipped_armor = ALL_DEFAULT_ITEMS["leather_vest_worn"]

        self.inventory = []
        self.gold = 20
        self.xp = 0
        self.level = 1
        self.chosen_class = chosen_class

    def get_total_attack(self):
        return self.attack_power + (self.equipped_weapon.damage if self.equipped_weapon else 0)


    def get_total_defense(self):
        base_defense = self.defense_power
        armor_bonus = self.equipped_armor.defense if self.equipped_armor else 0
        return base_defense + armor_bonus
    
    def add_item(self, item):
        self.inventory.append(item)
        log_event(f"Przedmiot '{item.name}' dodany do ekwipunku gracza '{self.name}'.", level="DEBUG")
        return f"{item.name} dodany do ekwipunku."

    def remove_item(self, item_name):
        for i, item in enumerate(self.inventory):
            if item.name.lower() == item_name.lower():
                removed_item = self.inventory.pop(i)
                log_event(f"Przedmiot '{removed_item.name}' usunięty z ekwipunku gracza '{self.name}'.", level="DEBUG")
                return removed_item
        return None

    def equip_item(self, item_name):
        item_to_equip = None
        item_index = -1
        for i, item_obj in enumerate(self.inventory):
            if item_obj.name.lower() == item_name.lower():
                item_to_equip = item_obj
                item_index = i
                break
        
        if not item_to_equip:
            return f"Nie masz przedmiotu {item_name} w ekwipunku."

        log_msg = ""
        if isinstance(item_to_equip, Weapon):
            if self.equipped_weapon: 
                self.add_item(self.equipped_weapon) 
                log_msg += f" Zdjęto {self.equipped_weapon.name}."
            self.equipped_weapon = item_to_equip
            self.inventory.pop(item_index)
            log_msg = f"Wyposażono {item_to_equip.name}." + log_msg
            log_event(f"Gracz '{self.name}' wyposażył broń: {item_to_equip.name}.", level="INFO")
        elif isinstance(item_to_equip, Armor):
            if self.equipped_armor:
                self.add_item(self.equipped_armor)
                log_msg += f" Zdjęto {self.equipped_armor.name}."
            self.equipped_armor = item_to_equip
            self.inventory.pop(item_index)
            log_msg = f"Wyposażono {item_to_equip.name}." + log_msg
            log_event(f"Gracz '{self.name}' wyposażył zbroję: {item_to_equip.name}.", level="INFO")
        else:
            log_msg = f"{item_to_equip.name} nie jest bronią ani zbroją."
        
        return log_msg

    def use_potion(self, potion_name):
        potion_to_use = None
        potion_index = -1
        for i, item in enumerate(self.inventory):
            if isinstance(item, Potion) and item.name.lower() == potion_name.lower():
                potion_to_use = item
                potion_index = i
                break
        
        if potion_to_use:
            success, message = potion_to_use.use(self) 
            if success:
                self.inventory.pop(potion_index)
                log_event(f"Gracz '{self.name}' użył mikstury '{potion_name}'. {message}", level="INFO")
                return True, message
            else:
                log_event(f"Nie udało się użyć mikstury '{potion_name}' przez gracza '{self.name}'. {message}", level="WARNING")
                return False, message
        else:
            msg = f"Nie masz mikstury {potion_name}."
            log_event(msg, level="INFO")
            return False, msg


    def add_xp(self, amount):
        self.xp += amount
        log_event(f"Gracz '{self.name}' zdobywa {amount} XP. Total XP: {self.xp}", level="INFO")
        gui_message = [f"Zdobywasz {amount} XP."]
        
        xp_needed_for_next_level = calculate_level_xp_threshold(self.level, base_xp=100, factor=1.2, exponent=1.5)
        
        while self.xp >= xp_needed_for_next_level:
            self.level += 1
            self.xp -= xp_needed_for_next_level
            
            self.max_hp += 10
            self.hp = self.max_hp
            self.attack_power += random.randint(1,2)
            self.defense_power += random.randint(0,1)

            level_up_msg = f"Awans na {self.level} poziom! Statystyki wzrosły. HP do {self.max_hp}, Atk do {self.attack_power}, Def do {self.defense_power}."
            log_event(f"Gracz '{self.name}' awansował na poziom {self.level}!", level="INFO", color=COLOR_GREEN)
            gui_message.append(level_up_msg)
            
            xp_needed_for_next_level = calculate_level_xp_threshold(self.level, base_xp=100, factor=1.2, exponent=1.5)
        
        return " ".join(gui_message)
            
    def to_dict(self):
        inventory_data = []
        for item in self.inventory:
            item_key = None
            for key, default_item in ALL_DEFAULT_ITEMS.items():
                if default_item.name == item.name:
                    item_key = key
                    break
            if item_key:
                inventory_data.append({"item_key": item_key})
            else:
                item_data = {"name": item.name, "type": item.__class__.__name__}
                if isinstance(item, Weapon): item_data.update({"damage": item.damage, "damage_dice": item.damage_dice})
                elif isinstance(item, Armor): item_data["defense"] = item.defense
                elif isinstance(item, Potion): item_data.update({"heal_amount": item.heal_amount, "effect": item.effect, "duration": item.duration})
                item_data["description"] = item.description
                item_data["value"] = item.value
                inventory_data.append(item_data)


        equipped_weapon_key = None
        if self.equipped_weapon:
            for key, item_obj in ALL_DEFAULT_ITEMS.items():
                if item_obj.name == self.equipped_weapon.name and isinstance(item_obj, Weapon):
                    equipped_weapon_key = key
                    break
        
        equipped_armor_key = None
        if self.equipped_armor:
            for key, item_obj in ALL_DEFAULT_ITEMS.items():
                if item_obj.name == self.equipped_armor.name and isinstance(item_obj, Armor):
                    equipped_armor_key = key
                    break

        return {
            "name": self.name,
            "chosen_class": self.chosen_class,
            "hp": self.hp,
            "max_hp": self.max_hp,
            "attack_power": self.attack_power,
            "defense_power": self.defense_power,
            "gold": self.gold,
            "xp": self.xp,
            "level": self.level,
            "inventory": inventory_data,
            "equipped_weapon_key": equipped_weapon_key,
            "equipped_armor_key": equipped_armor_key,
        }

    @classmethod
    def from_dict(cls, data, all_items_reference):
        player = cls(
            safe_nested_get(data, "name", "Bezimienny"), 
            safe_nested_get(data, "chosen_class", "Wojownik")
        )
        player.hp = safe_nested_get(data, "hp", player.max_hp)
        player.max_hp = safe_nested_get(data, "max_hp", player.max_hp)
        player.attack_power = safe_nested_get(data, "attack_power", player.attack_power)
        player.defense_power = safe_nested_get(data, "defense_power", player.defense_power)
        player.gold = safe_nested_get(data, "gold", player.gold)
        player.xp = safe_nested_get(data, "xp", player.xp)
        player.level = safe_nested_get(data, "level", player.level)

        player.inventory = []
        for item_data_entry in safe_nested_get(data, "inventory", []):
            item_key = safe_nested_get(item_data_entry, "item_key")
            if item_key and item_key in all_items_reference:
                player.add_item(all_items_reference[item_key])
            else:
                log_event(f"Nie można odtworzyć przedmiotu z ekwipunku: {item_data_entry}", level="WARNING")


        equipped_weapon_key = safe_nested_get(data, "equipped_weapon_key")
        if equipped_weapon_key and equipped_weapon_key in all_items_reference:
            item_obj = all_items_reference[equipped_weapon_key]
            if isinstance(item_obj, Weapon):
                 player.equipped_weapon = item_obj
            else:
                log_event(f"Próba wyposażenia '{equipped_weapon_key}' jako broń, ale to nie broń.", level="ERROR")
        elif not player.equipped_weapon:
             if player.chosen_class == "Wojownik": player.equipped_weapon = all_items_reference.get("old_sword")
             elif player.chosen_class == "Mag": player.equipped_weapon = all_items_reference.get("apprentice_staff_branch")
            
        equipped_armor_key = safe_nested_get(data, "equipped_armor_key")
        if equipped_armor_key and equipped_armor_key in all_items_reference:
            item_obj = all_items_reference[equipped_armor_key]
            if isinstance(item_obj, Armor):
                 player.equipped_armor = item_obj
            else:
                log_event(f"Próba wyposażenia '{equipped_armor_key}' jako zbroja, ale to nie zbroja.", level="ERROR")
        elif not player.equipped_armor:
            if player.chosen_class == "Wojownik": player.equipped_armor = all_items_reference.get("leather_vest_worn")
            elif player.chosen_class == "Mag": player.equipped_armor = all_items_reference.get("cloth_robe_simple")
        
        return player


class Enemy(Character):
    def __init__(self, name, hp, attack, defense, xp_reward, gold_reward, loot_table=None, attack_dice="1d4"):
        super().__init__(name, hp, attack, defense)
        self.xp_reward = xp_reward
        self.gold_reward = gold_reward
        self.loot_table = loot_table if loot_table else []
        self.attack_dice = attack_dice

    def attack_target(self, target):
        if not self.is_alive():
            return None, f"{self.name} nie może atakować, jest pokonany."

        base_damage = self.get_total_attack()
        try:
            weapon_damage_roll = roll_dice_expression(self.attack_dice)
        except ValueError as e:
            log_event(f"Błąd w notacji kości dla ataku wroga {self.name}: {e}", level="ERROR", color=COLOR_RED)
            weapon_damage_roll = random.randint(1, 4)

        potential_damage = base_damage + weapon_damage_roll
        potential_damage = max(1, potential_damage)

        log_event(f"Wróg {self.name} (Atk:{base_damage}) atakuje {target.name} z potencjalnymi obrażeniami: {potential_damage} (kość: {self.attack_dice} -> {weapon_damage_roll}).", level="INFO")
        
        actual_damage_inflicted, damage_message = target.take_damage(potential_damage)
        
        attack_log_message = f"{self.name} atakuje {target.name}. {damage_message}"
        return actual_damage_inflicted, attack_log_message


    def drop_loot(self):
        dropped_items = []
        if self.loot_table:
            for loot_entry in self.loot_table:
                item_ref, chance = loot_entry 
                if random.randint(1, 100) <= chance:
                    if isinstance(item_ref, str) and item_ref in ALL_DEFAULT_ITEMS:
                        dropped_items.append(ALL_DEFAULT_ITEMS[item_ref])
                    elif isinstance(item_ref, Item):
                        dropped_items.append(item_ref)
                    else:
                        log_event(f"Nieznany format łupu dla {self.name}: {item_ref}", level="WARNING")
            
        if dropped_items:
            log_event(f"{self.name} upuszcza łup: {[item.name for item in dropped_items]}", level="INFO", color=COLOR_GREEN)
        return dropped_items
--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\characters.py ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\game_logic.py ---
import random
import json
import os
from utils import calculate_level_xp_threshold, log_event, create_directory_if_not_exists, get_weighted_random_choice, roll_dice_expression, format_currency, safe_nested_get, get_percentage_chance, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_CYAN
from characters import Player, Enemy
from items import ALL_DEFAULT_ITEMS, Potion, Weapon, Armor, Item
SAVE_GAME_DIR = 'savegames'

class Game:

    def __init__(self, gui_callback_log, gui_callback_update_stats, gui_callback_combat_buttons):
        if not create_directory_if_not_exists(SAVE_GAME_DIR):
            log_event(f'Nie udało się utworzyć katalogu zapisu: {SAVE_GAME_DIR}. Zapis może nie działać.', level='ERROR', color=COLOR_RED)
        self.player = None
        self.current_enemy = None
        self.gui_log_message = gui_callback_log
        self.gui_update_stats = gui_callback_update_stats
        self.gui_update_combat_buttons = gui_callback_combat_buttons
        self.is_in_combat = False
        self.available_enemies_definitions = {'goblin_scout': {'name': 'Goblin Zwiadowca', 'hp': 30, 'attack': 3, 'defense': 2, 'xp': 25, 'gold': 10, 'attack_dice': '1d4+1', 'loot_table': [('small_health_potion', 30), ('rusty_dagger', 15)]}, 'orc_grunt': {'name': 'Orkowy Tępak', 'hp': 60, 'attack': 5, 'defense': 4, 'xp': 50, 'gold': 20, 'attack_dice': '1d8+2', 'loot_table': [('iron_sword', 10), ('medium_health_potion', 20), ('wolf_pelt', 40)]}, 'dark_wolf': {'name': 'Mroczny Wilk', 'hp': 45, 'attack': 4, 'defense': 3, 'xp': 35, 'gold': 15, 'attack_dice': '2d4', 'loot_table': [('wolf_pelt', 60), ('chipped_gemstone', 10)]}, 'forest_spider': {'name': 'Leśny Pająk', 'hp': 25, 'attack': 3, 'defense': 1, 'xp': 20, 'gold': 5, 'attack_dice': '1d6', 'loot_table': [('spider_silk', 50), ('antidote_weak', 10)]}}
        self.enemy_spawn_weights = {'goblin_scout': 40, 'orc_grunt': 20, 'dark_wolf': 30, 'forest_spider': 35}
        self.current_location_description = 'Stoisz na rozstaju dróg. Co robisz?'
        log_event('GameService zainicjalizowany.', level='DEBUG')

    def _get_save_path(self, username):
        return os.path.join(SAVE_GAME_DIR, f'{username}_save.json')

    def _log_to_gui(self, message):
        if self.gui_log_message:
            self.gui_log_message(message)

    def create_new_player(self, player_name, player_class):
        self.player = Player(player_name, player_class)
        self._log_to_gui(f'Witaj, {self.player.name}, {self.player.chosen_class}!')
        log_event(f'Utworzono nowego gracza: {player_name}, klasa: {player_class}', color=COLOR_GREEN)
        if player_class == 'Wojownik':
            self.player.add_item(ALL_DEFAULT_ITEMS['small_health_potion'])
        elif player_class == 'Mag':
            self.player.add_item(ALL_DEFAULT_ITEMS['medium_health_potion'])
        self.update_gui()
        return True

    def save_game(self, username):
        if not self.player:
            self._log_to_gui('Nie ma aktywnej gry do zapisania.')
            log_event('Próba zapisu gry bez aktywnego gracza.', level='WARNING')
            return False
        save_path = self._get_save_path(username)
        try:
            player_data = self.player.to_dict()
            game_state = {'player': player_data, 'current_location_description': self.current_location_description, 'version': '1.1'}
            with open(save_path, 'w') as f:
                json.dump(game_state, f, indent=4)
            self._log_to_gui(f'Gra zapisana dla {username}.')
            log_event(f'Gra zapisana do pliku: {save_path}', color=COLOR_GREEN)
            return True
        except Exception as e:
            self._log_to_gui(f'Błąd podczas zapisywania gry: {e}')
            log_event(f"Krytyczny błąd podczas zapisywania gry dla '{username}': {e}", level='ERROR', color=COLOR_RED)
            return False

    def load_game(self, username):
        save_path = self._get_save_path(username)
        if not os.path.exists(save_path):
            self._log_to_gui(f'Nie znaleziono zapisu dla {username}.')
            log_event(f"Nie znaleziono pliku zapisu dla '{username}': {save_path}", level='INFO')
            return False
        try:
            with open(save_path, 'r') as f:
                game_state = json.load(f)
            self.player = Player.from_dict(safe_nested_get(game_state, 'player', {}), ALL_DEFAULT_ITEMS)
            self.current_location_description = safe_nested_get(game_state, 'current_location_description', 'Nieznane miejsce.')
            self._log_to_gui(f'Gra wczytana dla {self.player.name}.')
            log_event(f"Gra wczytana z pliku: {save_path} dla gracza '{self.player.name}'", color=COLOR_GREEN)
            self.update_gui()
            self.is_in_combat = False
            self.current_enemy = None
            self.gui_update_combat_buttons(False)
            return True
        except Exception as e:
            self._log_to_gui(f'Błąd podczas wczytywania gry: {e}')
            log_event(f"Krytyczny błąd podczas wczytywania gry dla '{username}': {e}", level='ERROR', color=COLOR_RED)
            return False

    def explore(self):
        if self.is_in_combat:
            self._log_to_gui('Jesteś w trakcie walki!')
            return
        if not self.player or not self.player.is_alive():
            self._log_to_gui('Nie możesz eksplorować, gdy jesteś pokonany.')
            return
        self._log_to_gui('Rozglądasz się...')
        log_event(f"Gracz '{self.player.name}' eksploruje.", level='INFO')
        event_roll = roll_dice_expression('1d100')
        if event_roll <= 15:
            self.find_item_event()
        elif event_roll <= 75:
            self.start_encounter()
        elif event_roll <= 90:
            self.find_gold_event()
        else:
            self._log_to_gui('Nic ciekawego się nie wydarzyło.')
            log_event('Eksploracja: nic ciekawego.', level='DEBUG')
        self.update_gui()

    def find_item_event(self):
        possible_finds = {item_key: 1 for item_key, item_obj in ALL_DEFAULT_ITEMS.items() if not isinstance(item_obj, (Weapon, Armor)) or item_obj.value < 50}
        possible_finds['small_health_potion'] = 10
        possible_finds['iron_ore'] = 5
        possible_finds['stale_bread'] = 8
        found_item_key = get_weighted_random_choice(possible_finds)
        if found_item_key and found_item_key in ALL_DEFAULT_ITEMS:
            found_item = ALL_DEFAULT_ITEMS[found_item_key]
            self._log_to_gui(f'Znalazłeś {found_item.name}!')
            log_event(f'Gracz znalazł przedmiot: {found_item.name}', level='INFO', color=COLOR_GREEN)
            self.player.add_item(found_item)
        else:
            self._log_to_gui('Coś błysnęło w trawie, ale zniknęło, nim zdążyłeś zareagować.')
            log_event('Nie udało się wylosować przedmiotu podczas eksploracji.', level='DEBUG')

    def find_gold_event(self):
        amount = roll_dice_expression('2d10')
        self.player.gold += amount
        self._log_to_gui(f'Znalazłeś sakiewkę z {format_currency(amount)}!')
        log_event(f'Gracz znalazł {amount} złota.', level='INFO', color=COLOR_GREEN)

    def start_encounter(self):
        if self.is_in_combat:
            return
        if not self.player or not self.player.is_alive():
            return
        chosen_enemy_key = get_weighted_random_choice(self.enemy_spawn_weights)
        if not chosen_enemy_key or chosen_enemy_key not in self.available_enemies_definitions:
            log_event(f"Błąd: Nie udało się wylosować wroga lub definicja '{chosen_enemy_key}' nie istnieje.", level='ERROR', color=COLOR_RED)
            self._log_to_gui('Coś zaszurało w krzakach, ale uciekło.')
            return
        enemy_def = self.available_enemies_definitions[chosen_enemy_key]
        self.current_enemy = Enemy(name=enemy_def['name'], hp=enemy_def['hp'], attack=enemy_def['attack'], defense=enemy_def['defense'], xp_reward=enemy_def['xp'], gold_reward=enemy_def['gold'], loot_table=enemy_def.get('loot_table', []), attack_dice=enemy_def.get('attack_dice', '1d4'))
        self.is_in_combat = True
        self._log_to_gui(f'Spotykasz {self.current_enemy.name}!')
        self._log_to_gui(str(self.current_enemy))
        log_event(f"Rozpoczęto walkę: Gracz '{self.player.name}' vs Wróg '{self.current_enemy.name}'", level='INFO', color=COLOR_YELLOW)
        self.gui_update_combat_buttons(True)
        self.update_gui()

    def player_action_combat(self, action_type, param=None):
        if not self.is_in_combat or not self.player or (not self.current_enemy) or (not self.player.is_alive()):
            log_event('Próba akcji gracza poza walką lub gdy gracz/wróg nie istnieje.', level='WARNING')
            return
        action_message = ''
        if action_type == 'attack':
            _, action_message = self.player.attack_target(self.current_enemy)
        elif action_type == 'block':
            action_message = self.player.block()
        elif action_type == 'use_potion':
            if param:
                success, potion_message = self.player.use_potion(param)
                action_message = potion_message
                if not success:
                    self._log_to_gui(action_message)
                    self.update_gui()
                    return
            else:
                action_message = 'Musisz wybrać miksturę do użycia.'
        else:
            log_event(f'Nieznana akcja gracza w walce: {action_type}', level='ERROR')
            self._log_to_gui('Nieznana akcja.')
            return
        if action_message:
            self._log_to_gui(action_message)
        self.update_gui()
        if not self.current_enemy.is_alive():
            self.end_combat(victory=True)
        elif self.player.is_alive():
            self.enemy_turn()

    def enemy_turn(self):
        if not self.is_in_combat or not self.current_enemy or (not self.current_enemy.is_alive()) or (not self.player.is_alive()):
            return
        action_message = ''
        if self.current_enemy.hp < self.current_enemy.max_hp * 0.3 and get_percentage_chance(30):
            action_message = self.current_enemy.block()
            log_event(f"Wróg '{self.current_enemy.name}' blokuje.", level='DEBUG')
        else:
            _, action_message = self.current_enemy.attack_target(self.player)
            log_event(f"Wróg '{self.current_enemy.name}' atakuje gracza '{self.player.name}'.", level='DEBUG')
        if action_message:
            self._log_to_gui(action_message)
        self.update_gui()
        if not self.player.is_alive():
            self.end_combat(victory=False)

    def flee_combat(self):
        if not self.is_in_combat:
            return
        if get_percentage_chance(50):
            self._log_to_gui('Udało ci się uciec!')
            log_event(f"Gracz '{self.player.name}' uciekł z walki.", level='INFO', color=COLOR_YELLOW)
            self.is_in_combat = False
            self.current_enemy = None
            self.gui_update_combat_buttons(False)
        else:
            self._log_to_gui('Nie udało się uciec! Wróg korzysta z okazji.')
            log_event(f"Graczowi '{self.player.name}' nie udało się uciec.", level='INFO')
            self.enemy_turn()
        self.update_gui()

    def end_combat(self, victory):
        self.is_in_combat = False
        enemy_name = self.current_enemy.name if self.current_enemy else 'Nieznany Wróg'
        if victory and self.player:
            self._log_to_gui(f'Pokonałeś {enemy_name}!')
            xp_message = self.player.add_xp(self.current_enemy.xp_reward)
            self._log_to_gui(xp_message)
            gold_reward = self.current_enemy.gold_reward
            self.player.gold += gold_reward
            self._log_to_gui(f'Zdobywasz {format_currency(gold_reward)}.')
            log_event(f"Gracz '{self.player.name}' pokonał '{enemy_name}'. Zdobyto {self.current_enemy.xp_reward} XP i {gold_reward} złota.", color=COLOR_GREEN)
            dropped_loot = self.current_enemy.drop_loot()
            if dropped_loot:
                self._log_to_gui('Znaleziono łup:')
                for item in dropped_loot:
                    self._log_to_gui(f'- {item.name}')
                    self.player.add_item(item)
        elif not victory and self.player:
            self._log_to_gui(f'{self.player.name} został pokonany przez {enemy_name}. Koniec gry.')
            log_event(f"Gracz '{self.player.name}' został pokonany. GAME OVER.", level='CRITICAL', color=COLOR_RED)
            self.player = None
        self.current_enemy = None
        self.gui_update_combat_buttons(False)
        self.update_gui()

    def get_player_status(self):
        if not self.player:
            return 'Brak gracza.'
        xp_to_next_level = calculate_level_xp_threshold(self.player.level, base_xp=100, factor=1.2, exponent=1.5)
        status = f'Gracz: {self.player.name} ({self.player.chosen_class}) Poziom: {self.player.level}\n'
        status += f'HP: {self.player.hp}/{self.player.max_hp} Złoto: {format_currency(self.player.gold)} XP: {self.player.xp}/{xp_to_next_level}\n'
        status += f'Atak (bazowy): {self.player.attack_power} Obrona (bazowa): {self.player.defense_power}\n'
        if self.player.equipped_weapon:
            weapon_dmg_info = self.player.equipped_weapon.damage_dice if self.player.equipped_weapon.damage_dice else self.player.equipped_weapon.damage
            status += f'Broń: {self.player.equipped_weapon.name} (Obrażenia: {weapon_dmg_info})\n'
        if self.player.equipped_armor:
            status += f'Zbroja: {self.player.equipped_armor.name} (+{self.player.equipped_armor.defense} Obr.)\n'
        return status

    def get_enemy_status(self):
        if self.is_in_combat and self.current_enemy:
            return f'Wróg: {str(self.current_enemy)}'
        return ''

    def get_inventory_listing(self):
        if not self.player or not self.player.inventory:
            return 'Ekwipunek jest pusty.'
        listing = 'Ekwipunek:\n'
        for i, item in enumerate(self.player.inventory):
            listing += f'{i + 1}. {str(item)}\n'
        return listing

    def use_inventory_item(self, item_index_str):
        if not self.player or not self.player.is_alive():
            self._log_to_gui('Nie możesz teraz używać przedmiotów.')
            return
        try:
            item_index = int(item_index_str) - 1
            if 0 <= item_index < len(self.player.inventory):
                item_to_use = self.player.inventory[item_index]
                log_message_for_gui = ''
                if isinstance(item_to_use, Potion):
                    success, message = item_to_use.use(self.player)
                    log_message_for_gui = message
                    if success:
                        self.player.inventory.pop(item_index)
                        log_event(f'Gracz użył {item_to_use.name} poza walką. {message}', level='INFO')
                    else:
                        log_event(f'Nie udało się użyć {item_to_use.name} poza walką. {message}', level='WARNING')
                elif isinstance(item_to_use, (Weapon, Armor)):
                    log_message_for_gui = self.player.equip_item(item_to_use.name)
                else:
                    log_message_for_gui = f'{item_to_use.name} nie jest miksturą, bronią ani zbroją. Nie można go tak użyć.'
                self._log_to_gui(log_message_for_gui)
                self.update_gui()
            else:
                self._log_to_gui('Nieprawidłowy numer przedmiotu.')
        except ValueError:
            self._log_to_gui('Podaj numer przedmiotu.')
        except IndexError:
            self._log_to_gui('Przedmiot o podanym numerze nie istnieje w ekwipunku.')

    def update_gui(self):
        if self.player and self.player.is_alive():
            self.gui_update_stats(self.get_player_status(), self.get_enemy_status(), self.get_inventory_listing())
        elif self.player and (not self.player.is_alive()):
            self.gui_update_stats('GAME OVER', '', 'Twój ekwipunek przepadł w mroku...')
        else:
            self.gui_update_stats('Brak aktywnej gry.', '', '')

--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\game_logic.py ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\gui.py ---
import tkinter as tk
from tkinter import ttk, scrolledtext, simpledialog, messagebox
from items import Potion
from utils import log_event, COLOR_CYAN, format_currency

class RPGInterface:

    def __init__(self, root, auth_service, game_logic_service):
        self.root = root
        self.auth = auth_service
        self.game = game_logic_service
        self.current_username = None
        self.root.title('Proste RPG v1.1')
        self.root.geometry('850x650')
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure('TButton', padding=6, relief='flat', font=('Helvetica', 10))
        self.style.configure('Big.TButton', font=('Helvetica', 12, 'bold'))
        self.style.configure('Header.TLabel', font=('Helvetica', 14, 'bold'))
        self.style.configure('Status.TLabel', font=('Courier', 10), anchor='nw')
        self.style.configure('Inventory.TLabel', font=('Courier', 9), anchor='nw')
        self.create_login_screen()
        log_event('RPGInterface zainicjalizowane.', level='DEBUG', color=COLOR_CYAN)

    def clear_screen(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        log_event('Ekran wyczyszczony.', level='DEBUG')

    def create_login_screen(self):
        self.clear_screen()
        self.current_username = None
        if self.game:
            self.game.player = None
        login_frame = ttk.Frame(self.root, padding='20')
        login_frame.pack(expand=True)
        ttk.Label(login_frame, text='Logowanie / Rejestracja', style='Header.TLabel').pack(pady=10)
        ttk.Label(login_frame, text='Nazwa użytkownika:').pack(pady=5)
        self.username_entry = ttk.Entry(login_frame, width=30)
        self.username_entry.pack()
        ttk.Label(login_frame, text='Hasło:').pack(pady=5)
        self.password_entry = ttk.Entry(login_frame, show='*', width=30)
        self.password_entry.pack()
        button_frame = ttk.Frame(login_frame)
        button_frame.pack(pady=20)
        ttk.Button(button_frame, text='Zaloguj', command=self.handle_login, style='Big.TButton').pack(side=tk.LEFT, padx=10)
        ttk.Button(button_frame, text='Zarejestruj', command=self.handle_register, style='Big.TButton').pack(side=tk.LEFT, padx=10)
        self.login_status_label = ttk.Label(login_frame, text='')
        self.login_status_label.pack(pady=10)
        log_event('Utworzono ekran logowania.', level='DEBUG')

    def handle_login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        log_event(f'Próba logowania użytkownika: {username}', level='DEBUG')
        success, message = self.auth.login(username, password)
        self.login_status_label.config(text=message)
        if success:
            self.current_username = username
            self.show_character_or_game_screen()

    def handle_register(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        log_event(f'Próba rejestracji użytkownika: {username}', level='DEBUG')
        success, message = self.auth.register(username, password)
        self.login_status_label.config(text=message)
        if success:
            self.username_entry.delete(0, tk.END)
            self.password_entry.delete(0, tk.END)
            messagebox.showinfo('Rejestracja', 'Rejestracja udana! Możesz się teraz zalogować.')

    def show_character_or_game_screen(self):
        self.clear_screen()
        if self.game.load_game(self.current_username):
            self.create_main_game_screen()
            log_event(f'Gra wczytana dla {self.current_username}, przejście do ekranu gry.', level='INFO')
        else:
            self.create_character_creation_screen()
            log_event(f'Brak zapisu dla {self.current_username} lub błąd wczytania, przejście do tworzenia postaci.', level='INFO')

    def create_character_creation_screen(self):
        self.clear_screen()
        char_frame = ttk.Frame(self.root, padding='20')
        char_frame.pack(expand=True)
        ttk.Label(char_frame, text='Stwórz Postać', style='Header.TLabel').pack(pady=10)
        ttk.Label(char_frame, text='Nazwa Postaci:').pack(pady=5)
        self.char_name_entry = ttk.Entry(char_frame, width=30)
        self.char_name_entry.pack()
        if self.current_username:
            self.char_name_entry.insert(0, self.current_username)
        ttk.Label(char_frame, text='Wybierz klasę:').pack(pady=5)
        self.class_var = tk.StringVar(value='Wojownik')
        ttk.Radiobutton(char_frame, text='Wojownik (HP:100, Atk:10, Def:5)', variable=self.class_var, value='Wojownik').pack(anchor=tk.W)
        ttk.Radiobutton(char_frame, text='Mag (HP:70, Atk:8+broń, Def:3)', variable=self.class_var, value='Mag').pack(anchor=tk.W)
        ttk.Button(char_frame, text='Rozpocznij Grę', command=self.handle_start_new_game, style='Big.TButton').pack(pady=20)
        ttk.Button(char_frame, text='Wróć do logowania', command=self.create_login_screen).pack()
        log_event('Utworzono ekran tworzenia postaci.', level='DEBUG')

    def handle_start_new_game(self):
        char_name = self.char_name_entry.get()
        char_class = self.class_var.get()
        if not char_name:
            messagebox.showerror('Błąd', 'Nazwa postaci nie może być pusta.')
            return
        log_event(f'Rozpoczęcie nowej gry: Imię={char_name}, Klasa={char_class}', level='INFO')
        self.game.create_new_player(char_name, char_class)
        self.create_main_game_screen()

    def create_main_game_screen(self):
        self.clear_screen()
        main_pane = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main_pane.pack(fill=tk.BOTH, expand=True)
        left_frame = ttk.Frame(main_pane, padding=10)
        main_pane.add(left_frame, weight=3)
        ttk.Label(left_frame, text='Log Gry:', style='Header.TLabel').pack(anchor=tk.NW)
        self.log_text = scrolledtext.ScrolledText(left_frame, height=20, width=70, wrap=tk.WORD, state=tk.DISABLED, font=('Arial', 9))
        self.log_text.pack(fill=tk.BOTH, expand=True, pady=5)
        status_frame = ttk.Frame(left_frame)
        status_frame.pack(fill=tk.X, pady=5)
        self.player_status_label = ttk.Label(status_frame, text='Status Gracza:', style='Status.TLabel', justify=tk.LEFT)
        self.player_status_label.pack(anchor=tk.NW, fill=tk.X, pady=2)
        self.enemy_status_label = ttk.Label(status_frame, text='Status Wroga:', style='Status.TLabel', justify=tk.LEFT)
        self.enemy_status_label.pack(anchor=tk.NW, fill=tk.X, pady=2)
        right_frame = ttk.Frame(main_pane, padding=10)
        main_pane.add(right_frame, weight=2)
        actions_frame = ttk.LabelFrame(right_frame, text='Akcje Główne', padding=10)
        actions_frame.pack(fill=tk.X, pady=5)
        self.explore_button = ttk.Button(actions_frame, text='Eksploruj', command=self.game.explore)
        self.explore_button.pack(fill=tk.X, pady=2)
        self.save_button = ttk.Button(actions_frame, text='Zapisz Grę', command=lambda: self.game.save_game(self.current_username))
        self.save_button.pack(fill=tk.X, pady=2)
        self.logout_button = ttk.Button(actions_frame, text='Wyloguj', command=self.create_login_screen)
        self.logout_button.pack(fill=tk.X, pady=2)
        self.combat_frame = ttk.LabelFrame(right_frame, text='Walka', padding=10)
        self.combat_frame.pack(fill=tk.X, pady=5)
        self.attack_button = ttk.Button(self.combat_frame, text='Atakuj', command=lambda: self.game.player_action_combat('attack'))
        self.attack_button.pack(fill=tk.X, pady=2)
        self.block_button = ttk.Button(self.combat_frame, text='Blokuj', command=lambda: self.game.player_action_combat('block'))
        self.block_button.pack(fill=tk.X, pady=2)
        self.use_potion_button = ttk.Button(self.combat_frame, text='Użyj Mikstury (Walka)', command=self.handle_use_potion_combat)
        self.use_potion_button.pack(fill=tk.X, pady=2)
        self.flee_button = ttk.Button(self.combat_frame, text='Uciekaj', command=self.game.flee_combat)
        self.flee_button.pack(fill=tk.X, pady=2)
        self.update_combat_buttons_visibility(False)
        inventory_frame = ttk.LabelFrame(right_frame, text='Ekwipunek', padding=10)
        inventory_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        self.inventory_text = scrolledtext.ScrolledText(inventory_frame, height=10, width=45, wrap=tk.WORD, state=tk.DISABLED, font=('Courier', 9))
        self.inventory_text.pack(fill=tk.BOTH, expand=True, pady=5)
        item_action_frame = ttk.Frame(inventory_frame)
        item_action_frame.pack(fill=tk.X)
        ttk.Label(item_action_frame, text='Nr:').pack(side=tk.LEFT, padx=(0, 2))
        self.item_entry = ttk.Entry(item_action_frame, width=4)
        self.item_entry.pack(side=tk.LEFT, padx=(0, 5))
        self.item_entry.insert(0, '1')
        self.use_item_button = ttk.Button(item_action_frame, text='Użyj/Wyposaż', command=self.handle_use_inventory_item)
        self.use_item_button.pack(side=tk.LEFT, expand=True, fill=tk.X)
        log_event('Utworzono główny ekran gry.', level='DEBUG')
        if self.game.player:
            self.game.update_gui()
            if self.game.is_in_combat:
                self.update_combat_buttons_visibility(True)
        else:
            self.log_message('Błąd krytyczny: Brak danych gracza na głównym ekranie gry. Spróbuj wczytać grę ponownie lub stwórz nową postać.')
            log_event('Krytyczny błąd: Brak gracza na ekranie gry.', level='ERROR', color=COLOR_CYAN)

    def handle_use_inventory_item(self):
        item_num_str = self.item_entry.get()
        log_event(f'GUI: Próba użycia/wyposażenia przedmiotu z ekwipunku nr: {item_num_str}', level='DEBUG')
        self.game.use_inventory_item(item_num_str)

    def handle_use_potion_combat(self):
        if not self.game.player or not self.game.is_in_combat:
            return
        potions_in_inventory = [(i, item.name) for i, item in enumerate(self.game.player.inventory) if isinstance(item, Potion)]
        if not potions_in_inventory:
            self.log_message('Nie masz żadnych mikstur w ekwipunku.')
            return
        potion_name_to_use = simpledialog.askstring('Użyj Mikstury', 'Wpisz nazwę mikstury do użycia:', parent=self.root)
        if potion_name_to_use:
            log_event(f"GUI: Próba użycia mikstury '{potion_name_to_use}' w walce.", level='DEBUG')
            self.game.player_action_combat('use_potion', potion_name_to_use)
        else:
            self.log_message('Anulowano użycie mikstury.')

    def log_message(self, message):
        if hasattr(self, 'log_text'):
            self.log_text.config(state=tk.NORMAL)
            self.log_text.insert(tk.END, message + '\n')
            self.log_text.config(state=tk.DISABLED)
            self.log_text.see(tk.END)
        else:
            print(f'GUI_LOG_FALLBACK: {message}')

    def update_status_labels(self, player_status, enemy_status, inventory_listing):
        if hasattr(self, 'player_status_label'):
            self.player_status_label.config(text=player_status)
        if hasattr(self, 'enemy_status_label'):
            self.enemy_status_label.config(text=enemy_status)
        if hasattr(self, 'inventory_text'):
            self.inventory_text.config(state=tk.NORMAL)
            self.inventory_text.delete(1.0, tk.END)
            self.inventory_text.insert(tk.END, inventory_listing)
            self.inventory_text.config(state=tk.DISABLED)

    def update_combat_buttons_visibility(self, is_combat_active):
        if hasattr(self, 'attack_button'):
            can_act_in_combat = is_combat_active and self.game.player and self.game.player.is_alive()
            combat_button_state = tk.NORMAL if can_act_in_combat else tk.DISABLED
            self.attack_button.config(state=combat_button_state)
            self.block_button.config(state=combat_button_state)
            self.use_potion_button.config(state=combat_button_state)
            self.flee_button.config(state=combat_button_state)
            can_explore = not is_combat_active and self.game.player and self.game.player.is_alive()
            explore_state = tk.NORMAL if can_explore else tk.DISABLED
            self.explore_button.config(state=explore_state)
            can_save = not is_combat_active and self.game.player and self.game.player.is_alive()
            self.save_button.config(state=tk.NORMAL if can_save else tk.DISABLED)
            can_use_inventory = self.game.player and self.game.player.is_alive()
            if hasattr(self, 'use_item_button'):
                self.use_item_button.config(state=tk.NORMAL if can_use_inventory else tk.DISABLED)

--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\gui.py ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\items.py ---
from utils import log_event, format_currency, clamp, COLOR_GREEN

class Item:

    def __init__(self, name, description, value):
        self.name = name
        self.description = description
        self.value = value

    def __str__(self):
        return f'{self.name}: {self.description} (Wartość: {format_currency(self.value)})'

    def use(self, target):
        log_event(f"Próba użycia przedmiotu '{self.name}' na '{(target.name if hasattr(target, 'name') else target)}', który nie ma zdefiniowanej akcji 'use'.", level='WARNING')
        return False

class Weapon(Item):

    def __init__(self, name, description, value, damage, damage_dice=None):
        super().__init__(name, description, value)
        self.damage = damage
        self.damage_dice = damage_dice

    def __str__(self):
        dice_info = f' ({self.damage_dice})' if self.damage_dice else ''
        return f'{super().__str__()} (Bazowe obrażenia: {self.damage}{dice_info})'

class Armor(Item):

    def __init__(self, name, description, value, defense):
        super().__init__(name, description, value)
        self.defense = defense

    def __str__(self):
        return f'{super().__str__()} (Obrona: {self.defense})'

class Potion(Item):

    def __init__(self, name, description, value, heal_amount, effect=None, duration=0):
        super().__init__(name, description, value)
        self.heal_amount = heal_amount
        self.effect = effect
        self.duration = duration

    def __str__(self):
        details = []
        if self.heal_amount > 0:
            details.append(f'Leczenie: {self.heal_amount} HP')
        if self.effect:
            if isinstance(self.effect, dict):
                details.append(f'Efekt: +{self.effect['amount']} do {self.effect['stat']}' + (f' na {self.duration} tur' if self.duration > 0 else ''))
            else:
                details.append(f'Efekt: {self.effect.replace('_', ' ').capitalize()}')
        return f'{super().__str__()} ({(', '.join(details) if details else 'Brak specjalnych efektów')})'

    def use(self, target):
        used_successfully = False
        log_message_for_gui = []
        if self.heal_amount > 0 and hasattr(target, 'hp') and hasattr(target, 'max_hp'):
            hp_before = target.hp
            target.hp = clamp(target.hp + self.heal_amount, 0, target.max_hp)
            healed_amount = target.hp - hp_before
            if healed_amount > 0:
                msg = f'{target.name} używa {self.name} i leczy {healed_amount} HP (do {target.hp}/{target.max_hp}).'
                log_event(msg, level='INFO', color=COLOR_GREEN)
                log_message_for_gui.append(msg)
                used_successfully = True
            elif hp_before == target.max_hp:
                msg = f'{target.name} próbował użyć {self.name}, ale ma już pełne HP.'
                log_event(msg, level='INFO')
                log_message_for_gui.append(msg)
                used_successfully = True
            else:
                msg = f'{target.name} próbował użyć {self.name}, ale nie przyniosło to efektu leczniczego.'
                log_event(msg, level='WARNING')
                log_message_for_gui.append(msg)
        if self.effect:
            effect_msg = f'{target.name} odczuwa dodatkowy efekt mikstury {self.name} ({self.effect}).'
            log_event(effect_msg, level='INFO')
            log_message_for_gui.append(effect_msg)
            used_successfully = True
        if not used_successfully:
            no_effect_msg = f'{self.name} nie może być użyty na {target.name} lub nie ma zdefiniowanego efektu w tej sytuacji.'
            log_event(no_effect_msg, level='WARNING')
            return (False, no_effect_msg)
        return (True, ' '.join(log_message_for_gui))

DEFAULT_WEAPONS = {
    "splintered_club": Weapon("Drzazgowa Pałka", "Kawałek drewna, ledwo trzymający się kupy.", 1, 1, "1d2"),
    "kitchen_knife": Weapon("Nóż Kuchenny", "Zabrany w pośpiechu, lepszy niż nic.", 2, 1, "1d3"),
    "rusty_dagger": Weapon("Zardzewiały Sztylet", "Mały i szybki, ale niezbyt mocny.", 3, 2, "1d4"),
    "old_sword": Weapon("Stary Miecz", "Podstawowy miecz dla początkującego wojownika.", 0, 3, "1d6"),
    "hunting_spear_tip": Weapon("Grot Włóczni Myśliwskiej", "Sam grot, bez drzewca. Niewygodny.", 4, 2, "1d4"),
    "apprentice_staff_branch": Weapon("Gałąź Kostura Ucznia", "Złamany kostur, wciąż trochę magii.", 0, 2, "1d4+2"),
    "sling_with_pebbles": Weapon("Proca z Kamieniami", "Dziecięca zabawka, ale kamień może zaboleć.", 2, 1, "1d3"),
    "iron_dagger": Weapon("Żelazny Sztylet", "Solidny sztylet, dobry do szybkich cięć.", 15, 3, "1d4+1"),
    "iron_sword": Weapon("Żelazny Miecz", "Solidny miecz, dobrze wyważony.", 25, 4, "1d8"),
    "steel_axe": Weapon("Stalowy Topór", "Ciężki topór, zdolny przebić pancerz.", 30, 5, "1d10"),
    "mages_wand": Weapon("Różdżka Maga", "Różdżka skupiająca energię magiczną.", 35, 3, "1d6+3"),
    "oak_staff": Weapon("Dębowy Kostur", "Solidny kostur, wzmacniający proste zaklęcia.", 28, 4, "1d8+1"),
    "short_bow": Weapon("Krótki Łuk", "Zgrabny łuk dla zwiadowcy.", 20, 3, "1d6+1"),
    "spiked_mace": Weapon("Kolczasta Maczuga", "Drewniana maczuga z żelaznymi kolcami.", 22, 4, "2d4"),
    "war_hammer_light": Weapon("Lekki Młot Bojowy", "Mniejsza wersja młota bojowego.", 26, 4, "1d8+1"),
    "knights_arming_sword": Weapon("Miecz Rycerski Krótki", "Standardowa broń rycerza.", 60, 6, "1d10+2"),
    "elven_shortsword": Weapon("Elficki Krótki Miecz", "Lekki i ostry, dzieło elfów.", 70, 5, "1d8+3"),
    "dwarven_waraxe": Weapon("Krasnoludzki Topór Bojowy", "Solidny i niezawodny, jak jego twórcy.", 75, 7, "1d12+1"),
    "crystal_focus_staff": Weapon("Kryształowy Kostur Skupiający", "Kostur z magicznym kryształem na szczycie.", 80, 5, "2d6+3"),
    "longbow": Weapon("Długi Łuk", "Potężny łuk wymagający siły i wprawy.", 55, 5, "1d8+2"),
    "morning_star": Weapon("Gwiazda Zaranna", "Kolczasta kula na łańcuchu, przymocowana do rękojeści.", 65, 6, "2d6"),
    "obsidian_dagger": Weapon("Obsydianowy Sztylet", "Niezwykle ostry sztylet z wulkanicznego szkła.", 50, 4, "1d6+2"),
    "masterwork_longsword": Weapon("Mistrzowski Długi Miecz", "Perfekcyjnie wykonany miecz.", 150, 8, "2d8+2"),
    "great_axe_of_cleaving": Weapon("Wielki Topór Rąbiący", "Ogromny topór, zdolny przeciąć wroga na pół.", 160, 10, "2d10"),
    "archmages_battle_staff": Weapon("Bojowy Kostur Arcymaga", "Kostur nasycony potężnymi zaklęciami ofensywnymi.", 180, 7, "3d6+3"),
    "composite_bow": Weapon("Łuk Kompozytowy", "Zaawansowana konstrukcja, zapewniająca dużą siłę strzału.", 140, 7, "1d10+3"),
    "flanged_mace": Weapon("Buława Pierzasta", "Ciężka buława z metalowymi piórami, idealna przeciw pancerzom.", 130, 9, "2d8"),
    "shadowsteel_rapier": Weapon("Rapier z Cieniostali", "Smukły i szybki rapier, wykuty z rzadkiego metalu.", 170, 6, "1d8+4"),
    "blade_of_the_ancients": Weapon("Ostrze Starożytnych", "Legendarny miecz, pulsujący tajemną energią.", 500, 12, "3d8+5"),
    "axe_of_the_berserker_lord": Weapon("Topór Władcy Berserkerów", "Topór, który zdaje się szeptać obietnice rzezi.", 550, 15, "2d12+5"),
    "staff_of_the_cosmos": Weapon("Laska Kosmosu", "Fragment gwiazdy oprawiony w kostur, władający niepojętą mocą.", 600, 10, "4d6+6"),
    "dragons_breath_bow": Weapon("Łuk Smoczego Oddechu", "Łuk, którego strzały płoną ogniem.", 450, 10, "2d10+4"),
    "sunken_trident_of_depths": Weapon("Zatopiony Trójząb Głębin", "Trójząb odnaleziony w morskich otchłaniach.", 480, 11, "3d6+3"),
}

DEFAULT_ARMORS = {
    "rags": Armor("Łachmany", "Resztki ubrań, prawie bez ochrony.", 1, 0),
    "thick_clothes": Armor("Grube Ubranie", "Kilka warstw materiału, trochę lepiej niż nic.", 2, 1),
    "leather_vest_worn": Armor("Znoszona Skórzana Kamizelka", "Podstawowa ochrona, widziała lepsze dni.", 0, 2),
    "cloth_robe_simple": Armor("Prosta Płócienna Szata", "Lekka szata, oferująca minimalną ochronę.", 0, 1),
    "wooden_buckler": Armor("Drewniana Puklerz", "Mała tarcza z drewna.", 3, 1),
    "studded_leather_jerkin": Armor("Ćwiekowany Skórzany Kaftan", "Wzmocniona skórzana zbroja.", 20, 4),
    "chainmail_shirt": Armor("Koszula Kolcza", "Zapewnia dobrą ochronę przed cięciami.", 30, 6),
    "mages_apprentice_robe": Armor("Szata Ucznia Maga", "Szata utkana z prostych magicznych nici.", 25, 3),
    "iron_helmet_basic": Armor("Prosty Żelazny Hełm", "Chroni głowę przed lekkimi ciosami.", 15, 2),
    "reinforced_leather_armor": Armor("Wzmocniona Zbroja Skórzana", "Grubsza skóra z metalowymi płytkami.", 28, 5),
    "full_leather_armor": Armor("Pełna Zbroja Skórzana", "Kompletny strój ze skóry, dobrze dopasowany.", 55, 7),
    "steel_cuirass": Armor("Stalowy Kirys", "Solidna ochrona tułowia.", 70, 9),
    "enchanted_robe": Armor("Zaklęta Szata", "Szata nasycona podstawowymi zaklęciami ochronnymi.", 60, 5),
    "knights_helmet": Armor("Hełm Rycerski", "Solidny hełm zapewniający dobrą ochronę głowy.", 40, 4),
    "scale_mail": Armor("Zbroja Łuskowa", "Pancerz złożony z wielu małych, nachodzących na siebie płytek.", 65, 8),
    "plate_armor_standard": Armor("Standardowa Zbroja Płytowa", "Kompletna zbroja płytowa, doskonała ochrona.", 150, 13),
    "shadow_weave_robe": Armor("Szata z Cienistej Tkaniny", "Lekka szata, która zdaje się pochłaniać światło i ciosy.", 160, 9),
    "dwarven_plate": Armor("Krasnoludzka Zbroja Płytowa", "Niezwykle wytrzymała, choć ciężka.", 170, 15),
    "elven_chainmail_fine": Armor("Elficka Kolczuga Zacna", "Lekka, wytrzymała i piękna.", 140, 11),
    "tower_shield": Armor("Tarcza Wieżowa", "Ogromna tarcza zapewniająca znakomitą osłonę.", 100, 7),
    "armor_of_the_guardian": Armor("Zbroja Strażnika", "Legendarna zbroja, która sama zdaje się chronić nosiciela.", 500, 20),
    "robes_of_the_archlich": Armor("Szaty Arcylisza", "Szaty utkane z dusz i koszmarów, zapewniające mroczną ochronę.", 550, 15),
    "dragonscale_full_plate": Armor("Pełna Zbroja ze Smoczych Łusek", "Pancerz wykuty z łusek prastarego smoka.", 600, 25),
    "aegis_of_the_fallen_god": Armor("Egida Upadłego Boga", "Tarcza nasycona boską esencją, niemal niezniszczalna.", 450, 18),
    "celestial_battle_robe": Armor("Niebiańska Szata Bojowa", "Szata tkana ze światła gwiazd, dla świętych wojowników.", 520, 17),
}

DEFAULT_POTIONS = {
    "weak_healing_draught": Potion("Słaby Wywar Leczniczy", "Mętny płyn, leczy drobne zadrapania.", 5, 15),
    "small_health_potion": Potion("Mała Mikstura Zdrowia", "Przywraca trochę zdrowia.", 10, 30),
    "medium_health_potion": Potion("Średnia Mikstura Zdrowia", "Przywraca znaczną ilość zdrowia.", 25, 60),
    "large_health_potion": Potion("Duża Mikstura Zdrowia", "Całkowicie regeneruje większość ran.", 50, 120),
    "elixir_of_pure_healing": Potion("Eliksir Czystego Leczenia", "Krystalicznie czysty płyn, przywraca pełnię sił.", 100, 250),
    "troll_blood_potion": Potion("Mikstura Krwi Trolla", "Gęsta i cuchnąca, przyspiesza regenerację.", 70, 90, effect="regeneracja_lekka", duration=3),
    "potion_of_minor_strength": Potion("Mikstura Pomniejszej Siły", "Lekko zwiększa siłę fizyczną.", 30, 0, effect={"stat": "attack_power", "amount": 2}, duration=3),
    "potion_of_ogres_strength": Potion("Mikstura Siły Ogra", "Znacząco zwiększa siłę fizyczną.", 70, 0, effect={"stat": "attack_power", "amount": 5}, duration=3),
    "potion_of_cats_grace": Potion("Mikstura Kociej Zwinności", "Zwiększa zręczność i uniki.", 35, 0, effect={"stat": "defense_power", "amount": 2, "type": "dodge"}, duration=3),
    "potion_of_iron_skin": Potion("Mikstura Żelaznej Skóry", "Utwardza skórę, zwiększając odporność na ciosy.", 40, 0, effect={"stat": "defense_power", "amount": 3}, duration=3),
    "potion_of_mages_insight": Potion("Mikstura Wnikliwości Maga", "Wzmacnia koncentrację i moc magiczną.", 45, 0, effect={"stat": "magic_power", "amount": 4}, duration=3),
    "potion_of_heroism": Potion("Mikstura Heroizmu", "Wypełnia odwagą i zwiększa wszystkie zdolności bojowe.", 150, 20, effect="wszystkie_staty_boost", duration=2),
    "antidote_weak": Potion("Słabe Antidotum", "Neutralizuje łagodne trucizny.", 15, 0, effect="cure_mild_poison"),
    "antidote_strong": Potion("Mocne Antidotum", "Neutralizuje silne trucizny.", 40, 0, effect="cure_strong_poison"),
    "potion_of_invisibility_short": Potion("Mikstura Krótkiej Niewidzialności", "Zapewnia niewidzialność na krótki czas.", 60, 0, effect="invisibility", duration=2),
    "potion_of_water_breathing": Potion("Mikstura Wodnego Oddechu", "Pozwala oddychać pod wodą.", 20, 0, effect="water_breathing", duration=5),
    "philter_of_love_fake": Potion("Fałszywy Napój Miłosny", "Pachnie truskawkami. Nie działa.", 5, 0, effect="placebo"),
}

DEFAULT_MISC_ITEMS = {
    "iron_ore": Item("Ruda Żelaza", "Kawałek rudy żelaza, do przetopienia.", 3),
    "goblin_ear": Item("Ucho Goblina", "Popularne trofeum, czasem skupowane.", 1),
    "wolf_pelt": Item("Skóra Wilka", "Dobrej jakości skóra, nadaje się na ubrania.", 5),
    "spider_silk": Item("Pajęczy Jedwab", "Delikatny, ale wytrzymały jedwab.", 8),
    "glowing_mushroom": Item("Świecący Grzyb", "Grzyb emitujący słabe światło, używany w alchemii.", 4),
    "herbs_common": Item("Zwykłe Zioła", "Mieszanka pospolitych ziół leczniczych.", 2),
    "rare_flower_petal": Item("Płatek Rzadkiego Kwiatu", "Składnik potężnych mikstur.", 15),
    "chipped_gemstone": Item("Wyszczerbiony Klejnot", "Mały, uszkodzony klejnot.", 7),
    "flawed_ruby": Item("Skażony Rubin", "Rubin z wewnętrznymi skazami.", 20),
    "sapphire_small": Item("Mały Szafir", "Błyszczący niebieski kamień.", 50),
    "emerald_decent": Item("Przyzwoity Szmaragd", "Piękny zielony klejnot.", 120),
    "diamond_perfect_tiny": Item("Malutki Idealny Diament", "Nawet mały diament jest cenny.", 300),
    "gold_ring_simple": Item("Prosty Złoty Pierścień", "Obrączka ze złota.", 40),
    "silver_necklace_worn": Item("Srebrny Naszyjnik Znoszony", "Kiedyś piękny, teraz trochę zniszczony.", 25),
    "ivory_figurine": Item("Figurka z Kości Słoniowej", "Mała, rzeźbiona figurka.", 75),
    "stale_bread": Item("Czerstwy Chleb", "Twardy, ale jadalny.", 1),
    "dried_meat": Item("Suszone Mięso", "Długo zachowuje świeżość.", 3),
    "apple_red": Item("Czerwone Jabłko", "Soczyste i słodkie.", 2),
    "waterskin": Item("Bukłak z Wodą", "Niezbędny w podróży.", 1),
    "cheap_wine": Item("Tanie Wino", "Kwaśne, ale rozgrzewa.", 4),
    "tattered_scroll": Item("Podarty Zwój", "Nieczytelne pismo na starym pergaminie.", 2),
    "book_local_history": Item("Księga Historii Lokalnej", "Opisuje dzieje najbliższej okolicy.", 10),
    "journal_adventurer": Item("Dziennik Podróżnika", "Zapiski nieznanego poszukiwacza przygód.", 15),
    "map_fragment_unknown": Item("Fragment Nieznanej Mapy", "Część większej mapy, miejsce nie do rozpoznania.", 8),
}

ALL_DEFAULT_ITEMS = {
    **DEFAULT_WEAPONS,
    **DEFAULT_ARMORS,
    **DEFAULT_POTIONS,
    **DEFAULT_MISC_ITEMS
    # te gwiazdki to laczenie slownikow
}
--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\items.py ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\main.py ---
# main.py
import tkinter as tk
from auth import AuthService
from game_logic import Game
from gui import RPGInterface
from utils import log_event, COLOR_CYAN, DEBUG_MODE

def main():
    log_event("Uruchamianie aplikacji RPG...", color=COLOR_CYAN, timestamp=True)
    root = tk.Tk()

    auth_service = AuthService()
    
    app_gui_instance = None

    def gui_log_callback(message):
        if app_gui_instance: app_gui_instance.log_message(message)
        log_event(f"GUI_MSG: {message}", level="DEBUG", timestamp=False)


    def gui_status_update_callback(player_status, enemy_status, inventory_listing):
        if app_gui_instance: app_gui_instance.update_status_labels(player_status, enemy_status, inventory_listing)
            
    def gui_combat_buttons_callback(is_active):
        if app_gui_instance: app_gui_instance.update_combat_buttons_visibility(is_active)

    game_service = Game(
        gui_callback_log=gui_log_callback,
        gui_callback_update_stats=gui_status_update_callback,
        gui_callback_combat_buttons=gui_combat_buttons_callback
    )

    app_gui_instance = RPGInterface(root, auth_service, game_service)

    log_event("Aplikacja RPG zainicjalizowana i uruchomiona.", color=COLOR_CYAN)
    root.mainloop()
    log_event("Aplikacja RPG zakończyła działanie.", color=COLOR_CYAN, timestamp=True)


if __name__ == "__main__":
    main()
--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\main.py ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\users.json ---

--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\users.json ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\utils.py ---
import random
import re
import math
import textwrap
from collections import defaultdict
import datetime
DEBUG_MODE = True
COLOR_RED = '\x1b[91m'
COLOR_GREEN = '\x1b[92m'
COLOR_YELLOW = '\x1b[93m'
COLOR_BLUE = '\x1b[94m'
COLOR_MAGENTA = '\x1b[95m'
COLOR_CYAN = '\x1b[96m'
COLOR_RESET = '\x1b[0m'

def log_event(message, level='INFO', color=None, timestamp=True):
    if level.upper() == 'DEBUG' and (not DEBUG_MODE):
        return
    time_str = f'[{datetime.datetime.now():%Y-%m-%d %H:%M:%S}] ' if timestamp else ''
    log_prefix = f'[{level.upper()}]'
    full_message = f'{time_str}{log_prefix} {message}'
    if color:
        full_message = f'{color}{full_message}{COLOR_RESET}'
    print(full_message)

def generate_random_syllabic_name(min_syl=2, max_syl=4, title_chance=0.1):
    vowels = 'aeiouy'
    consonants = 'bcdfghjklmnprstvwz'
    titles = ['Sir', 'Lady', 'Lord', 'Dame', 'Elder', 'Captain']
    name = ''
    num_syllables = random.randint(min_syl, max_syl)
    for i in range(num_syllables):
        syl = ''
        if random.choice([True, False]):
            syl += random.choice(consonants)
            syl += random.choice(vowels)
            if random.random() < 0.2:
                syl += random.choice(vowels)
        else:
            syl += random.choice(vowels)
            syl += random.choice(consonants)
        if i == 0:
            name += syl.capitalize()
        else:
            name += syl
    if random.random() < title_chance:
        name = f'{random.choice(titles)} {name}'
    return name

def truncate_text(text, max_length=100, suffix='...'):
    if len(text) <= max_length:
        return text
    else:
        return text[:max_length - len(suffix)] + suffix

def format_currency(amount, currency_symbol='zł'):
    return f'{amount:.0f} {currency_symbol}'

def text_to_list_of_words(text, lower=False):
    text = re.sub('[^\\w\\s]', '', text)
    if lower:
        text = text.lower()
    return text.split()

def roll_dice_expression(expression):
    original_expression = expression
    expression = expression.lower().replace(' ', '')
    match = re.match('(\\d*)d(\\d+)([+-]\\d+)?', expression)
    if not match:
        raise ValueError(f'Nieprawidłowy format rzutu kostką: {original_expression}')
    num_dice_str, die_type_str, modifier_str = match.groups()
    num_dice = int(num_dice_str) if num_dice_str else 1
    die_type = int(die_type_str)
    modifier = int(modifier_str) if modifier_str else 0
    if num_dice <= 0 or die_type <= 0:
        raise ValueError('Liczba kości i typ kości muszą być dodatnie.')
    total_roll = sum((random.randint(1, die_type) for _ in range(num_dice)))
    return total_roll + modifier

def get_percentage_chance(percentage):
    if not 0 <= percentage <= 100:
        raise ValueError('Procent musi być z zakresu 0-100.')
    return random.randint(0, 99) < percentage

def clamp(value, min_value, max_value):
    return max(min_value, min(value, max_value))

def calculate_level_xp_threshold(level, base_xp=100, factor=1.5, exponent=2):
    if level <= 0:
        return 0
    return int(base_xp * level ** exponent * factor)

def get_weighted_random_choice(choices_dict):
    if not choices_dict:
        return None
    total_weight = sum(choices_dict.values())
    if total_weight <= 0:
        return random.choice(list(choices_dict.keys()))
    rand_val = random.uniform(0, total_weight)
    cumulative_weight = 0
    for item, weight in choices_dict.items():
        cumulative_weight += weight
        if rand_val <= cumulative_weight:
            return item
    return None

def safe_nested_get(dictionary, keys, default=None):
    if isinstance(keys, str):
        keys = keys.split('.')
    current_level = dictionary
    for key in keys:
        if isinstance(current_level, dict) and key in current_level:
            current_level = current_level[key]
        else:
            return default
    return current_level

def group_by_key(list_of_dicts, key_to_group_by):
    grouped = defaultdict(list)
    for item_dict in list_of_dicts:
        if key_to_group_by in item_dict:
            grouped[item_dict[key_to_group_by]].append(item_dict)
    return dict(grouped)

def create_directory_if_not_exists(dir_path):
    import os
    if not os.path.exists(dir_path):
        try:
            os.makedirs(dir_path)
            log_event(f'Utworzono katalog: {dir_path}', level='DEBUG')
            return True
        except OSError as e:
            log_event(f'Błąd podczas tworzenia katalogu {dir_path}: {e}', level='ERROR', color=COLOR_RED)
            return False
    return True
if __name__ == '__main__':
    log_event('Rozpoczęto testowanie modułu utils.py', color=COLOR_CYAN)
    print('\n--- Testy Tekstowe ---')
    for _ in range(3):
        print(f'Losowe imię: {generate_random_syllabic_name()}')
    print(f'Obcięty tekst: {truncate_text('To jest bardzo długi tekst, który na pewno zostanie obcięty.', 20)}')
    print(f'Sformatowana waluta: {format_currency(1234.56)}')
    print(f'Tekst na słowa: {text_to_list_of_words('Witaj, świecie! Jak się masz?', lower=True)}')
    print('\n--- Testy Matematyczne i Losowe ---')
    print(f'Rzut 2d6+5: {roll_dice_expression('2d6+5')}')
    print(f'Rzut d100: {roll_dice_expression('d100')}')
    print(f'Szansa 50%: {get_percentage_chance(50)}')
    print(f'Clamp(15, 0, 10): {clamp(15, 0, 10)}')
    print(f'XP dla poziomu 10: {calculate_level_xp_threshold(10, factor=1.2, exponent=2.1)}')
    print('\n--- Testy Struktur Danych ---')
    loot_table = {'Złoto': 60, 'Mikstura': 30, 'Miecz': 10}
    print(f'Ważony wybór z {loot_table}: {get_weighted_random_choice(loot_table)}')
    test_dict = {'user': {'profile': {'name': 'Tester', 'age': 99}, 'settings': {'theme': 'dark'}}}
    print(f"Safe get 'user.profile.name': {safe_nested_get(test_dict, 'user.profile.name')}")
    print(f"Safe get 'user.settings.font' (default): {safe_nested_get(test_dict, 'user.settings.font', 'Arial')}")
    data_to_group = [{'category': 'A', 'value': 1}, {'category': 'B', 'value': 2}, {'category': 'A', 'value': 3}, {'category': 'C', 'value': 4}]
    print(f"Grupowanie po 'category': {group_by_key(data_to_group, 'category')}")
    print('\n--- Testy Systemowe/Plikowe ---')
    test_dir = 'temp_test_dir_utils'
    if create_directory_if_not_exists(test_dir):
        log_event(f'Katalog {test_dir} istnieje lub został utworzony.', color=COLOR_GREEN)
    log_event('Zakończono testowanie modułu utils.py', color=COLOR_CYAN)

--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\utils.py ---

--- START OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\savegames\Halo_save.json ---

--- END OF: C:/Users/naksu/Documents/WorkSpace/ProjektInfa/S2\savegames\Halo_save.json ---

Łączna liczba istotnych linii kodu (bez pustych, printów i komentarzy): 1195
